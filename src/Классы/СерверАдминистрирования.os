
Перем Лог;
Перем ЭтоWindows;

Перем АдресСервераАдминистрирования;
Перем ПутьКлиентаАдминистрирования;
Перем ИмяБазыДанных;
Перем АдминистраторИБ;
Перем ПарольАдминистратораИБ;
Перем АдминистраторКластера;
Перем ПарольАдминистратораКластера;
Перем ИспользуемаяВерсияПлатформы;
Перем КлючРазрешенияЗапуска;

Перем КлючиАвторизацииВКластере;
Перем ИдентификаторКластера;

Перем КлючиАвторизацииВБазе;
Перем ИдентификаторБазы;

Функция Инициализация(лАдресСервераАдминистрирования = "localhost:1545",
	                  лПутьДоКлиентаАдминистрирования = "",
					  лИмяБазыДанных = "",
					  лАдминистраторИБ = "",
					  лПарольАдминистратораИБ = "",
					  лАдминистраторКластера = "",
					  лПарольАдминистратораКластера = "",
					  лИспользуемаяВерсияПлатформы = "",
					  лКлючРазрешенияЗапуска = "") Экспорт


	АдресСервераАдминистрирования = лАдресСервераАдминистрирования;
	ПутьКлиентаАдминистрирования  = лПутьДоКлиентаАдминистрирования;
	ИмяБазыДанных                 = лИмяБазыДанных;
	АдминистраторИБ               = лАдминистраторИБ;
	ПарольАдминистратораИБ        = лПарольАдминистратораИБ;
	АдминистраторКластера         = лАдминистраторКластера;
	ПарольАдминистратораКластера  = лПарольАдминистратораКластера;
	ИспользуемаяВерсияПлатформы   = лИспользуемаяВерсияПлатформы;
	КлючРазрешенияЗапуска         = лКлючРазрешенияЗапуска;
	
	ПутьКлиентаАдминистрирования = ПолучитьПутьКRAC();

	КлючиАвторизацииВКластере = КлючиАвторизацииВКластере();
	ИдентификаторКластера = ИдентификаторКластера();

	КлючиАвторизацииВБазе = КлючиАвторизацииВБазе();	
	ИдентификаторБазы = ИдентификаторБазы();
	
КонецФункции

Функция УстановитьСтатусБлокировкиСеансов(Блокировать, ВремяБлокировки="", СообщениеОблокировке="", ЧислоПопыток=1) Экспорт

	Результат = Ложь;

	КомандаВыполнения = СтрокаЗапускаКлиента() + СтрШаблон("infobase update --infobase=""%3""%4 --cluster=""%1""%2 --sessions-deny=%5 --denied-message=""%6"" --denied-from=""%8"" --permission-code=""%7""",
		ИдентификаторКластера,
		КлючиАвторизацииВКластере,
		ИдентификаторБазы,
		КлючиАвторизацииВБазе,
		?(Блокировать, "on", "off"), 
		СообщениеОблокировке, 
		КлючРазрешенияЗапуска, 
		ВремяБлокировки) + " "+АдресСервераАдминистрирования;
	
	Для Сч = 1 По ЧислоПопыток Цикл
		Попытка
			ЗапуститьПроцесс(КомандаВыполнения);
			Лог.Информация("Сеансы " + ?(Блокировать, "запрещены", "разрешены"));
			Результат = Истина;
			Прервать;
		Исключение
			Лог.Предупреждение("Попытка запуска rac не удалась. Текст ошибки:
			|%1", ИнформацияОбОшибке().Описание);
		КонецПопытки;
	КонецЦикла;

	Возврат Результат;
	
КонецФункции

Процедура УстановитьСтатусБлокировкиРегламентныхЗаданий(Блокировать) Экспорт

	КомандаВыполнения = СтрокаЗапускаКлиента() + СтрШаблон("infobase update --infobase=""%3""%4 --cluster=""%1""%2 --scheduled-jobs-deny=%5",
		ИдентификаторКластера,
		КлючиАвторизацииВКластере,
		ИдентификаторБазы,
		КлючиАвторизацииВБазе,
		?(Блокировать, "on", "off")) + " "+АдресСервераАдминистрирования;

	ЗапуститьПроцесс(КомандаВыполнения);
	
	Лог.Информация("Запуск регламентных заданий " + ?(Блокировать, "запрещен", "разрешен"));

КонецПроцедуры	

Процедура ОтключитьСуществующиеСеансы() Экспорт
	
	Лог.Информация("Отключаю существующие сеансы");
	
	СеансыБазы = ПолучитьСписокСеансов();
	Для Каждого Сеанс Из СеансыБазы Цикл
		Попытка
			ОтключитьСеанс(Сеанс);
		Исключение
			Лог.Ошибка(ОписаниеОшибки());
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьСписокСеансов() Экспорт
	
	ТаблицаСеансов = Новый ТаблицаЗначений;
	ТаблицаСеансов.Колонки.Добавить("Идентификатор");
	ТаблицаСеансов.Колонки.Добавить("Приложение");
	ТаблицаСеансов.Колонки.Добавить("Пользователь");
	ТаблицаСеансов.Колонки.Добавить("НомерСеанса");
	
	КомандаЗапуска = СтрокаЗапускаКлиента() + СтрШаблон("session list --cluster=""%1""%2 --infobase=""%3""",
	ИдентификаторКластера, 
	КлючиАвторизацииВКластере,
	ИдентификаторБазы) + " " + АдресСервераАдминистрирования;
	
	СписокСеансовИБ = ЗапуститьПроцесс(КомандаЗапуска);	
	
	Данные = РазобратьПоток(СписокСеансовИБ);
	
	Для Каждого Элемент Из Данные Цикл
		
		ТекСтрока = ТаблицаСеансов.Добавить();
		ТекСтрока.Идентификатор = Элемент["session"];
		ТекСтрока.Пользователь  = Элемент["user-name"];
		ТекСтрока.Приложение    = Элемент["app-id"];
		ТекСтрока.НомерСеанса   = Элемент["session-id"];
		
	КонецЦикла;
	
	Возврат ТаблицаСеансов;
	
КонецФункции

Процедура ОтключитьСеанс(Знач Сеанс)
	
	СтрокаВыполнения = СтрокаЗапускаКлиента() + СтрШаблон("session terminate --cluster=""%1""%2 --session=""%3""",
	ИдентификаторКластера,
	КлючиАвторизацииВКластере,
	Сеанс.Идентификатор) + " " + АдресСервераАдминистрирования;
	
	Лог.Информация(СтрШаблон("Отключаю сеанс: %1 [%2] (%3)", Сеанс.НомерСеанса, Сеанс.Пользователь, Сеанс.Приложение));
	
	ЗапуститьПроцесс(СтрокаВыполнения);
	
КонецПроцедуры

Функция ОтключитьСоединенияСРабочимиПроцессами() Экспорт
	
	Процессы = ПолучитьСписокРабочихПроцессов();
	
	Для Каждого РабочийПроцесс Из Процессы Цикл
		Если РабочийПроцесс["running"] = "yes" Тогда
			
			СписокСоединений = ПолучитьСоединенияРабочегоПроцесса(РабочийПроцесс);
			Для Каждого Соединение Из СписокСоединений Цикл
				
				Попытка
					РазорватьСоединениеСПроцессом(РабочийПроцесс, Соединение);
				Исключение
					Лог.Ошибка(ОписаниеОшибки());
				КонецПопытки;
				
			КонецЦикла;
			
		КонецЕсли;
	КонецЦикла;
	
КонецФункции

Функция ПолучитьСписокРабочихПроцессов()
	
	КомандаЗапускаПроцессы = СтрокаЗапускаКлиента() + СтрШаблон("process list --cluster=""%1""%2",
	ИдентификаторКластера, 
	КлючиАвторизацииВКластере) + " " + АдресСервераАдминистрирования;
	
	Лог.Информация("Получаю список рабочих процессов...");
	СписокПроцессов = ЗапуститьПроцесс(КомандаЗапускаПроцессы);
	
	Возврат РазобратьПоток(СписокПроцессов);
	
КонецФункции

Функция ПолучитьСоединенияРабочегоПроцесса(Знач РабочийПроцесс)
	
	КомандаЗапускаСоединения = СтрокаЗапускаКлиента() + СтрШаблон("connection list --cluster=""%1""%2 --infobase=%3%4 --process=%5",
	ИдентификаторКластера, 
	КлючиАвторизацииВКластере,
	ИдентификаторБазы,
	КлючиАвторизацииВБазе,
	РабочийПроцесс["process"]) + " " + АдресСервераАдминистрирования;
	
	Лог.Информация("Получаю список соединений...");
	Возврат РазобратьПоток(ЗапуститьПроцесс(КомандаЗапускаСоединения));
	
КонецФункции

Функция РазорватьСоединениеСПроцессом(Знач РабочийПроцесс, Знач Соединение)
	
	КомандаРазрывСоединения = СтрокаЗапускаКлиента() + СтрШаблон("connection disconnect --cluster=""%1""%2 --infobase=%3%4 --process=%5 --connection=%6",
	ИдентификаторКластера, 
	КлючиАвторизацииВКластере,
	ИдентификаторБазы,
	КлючиАвторизацииВБазе,
	РабочийПроцесс["process"],
	Соединение["connection"]) + " " + АдресСервераАдминистрирования;
	
	Сообщение = СтрШаблон("Отключаю соединение %1 [%2] (%3)",
	Соединение["conn-id"],
	Соединение["app-id"],
	Соединение["user-name"]);
	
	Лог.Информация(Сообщение);
	
	Возврат ЗапуститьПроцесс(КомандаРазрывСоединения);
	
КонецФункции

Функция РазобратьПоток(Знач Поток) Экспорт
	
	ТД = Новый ТекстовыйДокумент;
	ТД.УстановитьТекст(Поток);
	
	СписокОбъектов = Новый Массив;
	ТекущийОбъект = Неопределено;
	
	Для Сч = 1 По ТД.КоличествоСтрок() Цикл
		
		Текст = ТД.ПолучитьСтроку(Сч);
		Если ПустаяСтрока(Текст) или ТекущийОбъект = Неопределено Тогда
			Если ТекущийОбъект <> Неопределено и ТекущийОбъект.Количество() = 0 Тогда
				Продолжить; // очередная пустая строка подряд
			КонецЕсли;
			
			ТекущийОбъект = Новый Соответствие;
			СписокОбъектов.Добавить(ТекущийОбъект);
		КонецЕсли;
		
		СтрокаРазбораИмя      = "";
		СтрокаРазбораЗначение = "";
		
		Если РазобратьНаКлючИЗначение(Текст, СтрокаРазбораИмя, СтрокаРазбораЗначение) Тогда
			ТекущийОбъект[СтрокаРазбораИмя] = СтрокаРазбораЗначение;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ТекущийОбъект <> Неопределено и ТекущийОбъект.Количество() = 0 Тогда
		СписокОбъектов.Удалить(СписокОбъектов.ВГраница());
	КонецЕсли; 
	
	Возврат СписокОбъектов;
	
КонецФункции

Функция РазобратьНаКлючИЗначение(Знач СтрокаРазбора, Ключ, Значение)
	
	ПозицияРазделителя = Найти(СтрокаРазбора, ":");
	Если ПозицияРазделителя = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Ключ     = СокрЛП(Лев(СтрокаРазбора, ПозицияРазделителя - 1));
	Значение = СокрЛП(Сред(СтрокаРазбора, ПозицияРазделителя + 1));
	
	Возврат Истина;
	
КонецФункции



Функция ПолучитьПутьКRAC()

	Результат = "";
	
	Если НЕ ПустаяСтрока(ПутьКлиентаАдминистрирования) Тогда 
		ФайлУтилиты = Новый Файл(ПутьКлиентаАдминистрирования);
		Если ФайлУтилиты.Существует() Тогда 
			Лог.Отладка("Текущая версия rac " + ФайлУтилиты.ПолноеИмя);
			Возврат ФайлУтилиты.ПолноеИмя;
		КонецЕсли;
	КонецЕсли;
	
	Если ПустаяСтрока(ИспользуемаяВерсияПлатформы) Тогда 
		ИспользуемаяВерсияПлатформы = "8.3";
	КонецЕсли;
	
	Конфигуратор = Новый УправлениеКонфигуратором;
	ПутьКПлатформе = Конфигуратор.ПолучитьПутьКВерсииПлатформы(ИспользуемаяВерсияПлатформы);
	Лог.Отладка("Используемый путь для поиска rac " + ПутьКПлатформе);
	КаталогУстановки = Новый Файл(ПутьКПлатформе);
	Лог.Отладка(КаталогУстановки.Путь);
	
	
	ИмяФайла = ?(ЭтоWindows, "rac.exe", "rac");
	
	ФайлУтилиты = Новый Файл(ОбъединитьПути(Строка(КаталогУстановки.Путь), ИмяФайла));
	Если ФайлУтилиты.Существует() Тогда 
		Лог.Отладка("Текущая версия rac " + ФайлУтилиты.ПолноеИмя);
		Возврат ФайлУтилиты.ПолноеИмя;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция КлючиАвторизацииВБазе()

	Результат = "";

	Если ЗначениеЗаполнено(АдминистраторИБ) Тогда
		Результат = Результат + СтрШаблон(" --infobase-user=""%1""", АдминистраторИБ);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПарольАдминистратораИБ) Тогда
		Результат = Результат + СтрШаблон(" --infobase-pwd=""%1""", ПарольАдминистратораИБ);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция КлючиАвторизацииВКластере()

	Результат = "";

	Если ЗначениеЗаполнено(АдминистраторКластера) Тогда
		Результат = Результат + СтрШаблон(" --cluster-user=""%1""", АдминистраторКластера);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПарольАдминистратораКластера) Тогда
		Результат = Результат + СтрШаблон(" --cluster-pwd=""%1""", ПарольАдминистратораКластера);
	КонецЕсли;

	Возврат Результат;

КонецФункции

Функция ИдентификаторКластера()

	Результат = "";

	Лог.Информация("Получаю список кластеров");
		
	КомандаВыполнения = СтрокаЗапускаКлиента() + "cluster list" + " " + АдресСервераАдминистрирования;
	   
	СписокКластеров = ЗапуститьПроцесс(КомандаВыполнения);
	   
	УИДКластера = Сред(СписокКластеров, (Найти(СписокКластеров, ":") + 1), Найти(СписокКластеров, "host") - Найти(СписокКластеров, ":") - 1);	
	Результат = СокрЛП(СтрЗаменить(УИДКластера, Символы.ПС, ""));
	
	Если ПустаяСтрока(Результат) Тогда
		ВызватьИсключение "Кластер серверов отсутствует";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ИдентификаторБазы()
	
	КомандаВыполнения = СтрокаЗапускаКлиента() + СтрШаблон("infobase summary list --cluster=""%1""%2",
	ИдентификаторКластера, 
	КлючиАвторизацииВКластере) + " " + АдресСервераАдминистрирования;
	
	Лог.Информация("Получаю список баз кластера");
	
	СписокБазВКластере = СокрЛП(ЗапуститьПроцесс(КомандаВыполнения));    
	Лог.Отладка(СписокБазВКластере);
	ЧислоСтрок = СтрЧислоСтрок(СписокБазВКластере);
	НайденаБазаВКластере = Ложь;
	Для К = 1 По ЧислоСтрок Цикл
		
		СтрокаРазбора = СтрПолучитьСтроку(СписокБазВКластере, К);   
		ПозицияРазделителя = Найти(СтрокаРазбора, ":");
		Если Найти(СтрокаРазбора, "infobase") > 0 Тогда						
			УИДИБ =  СокрЛП(Сред(СтрокаРазбора, ПозицияРазделителя + 1));	
		ИначеЕсли Найти(СтрокаРазбора, "name") > 0 Тогда 
			ИмяБазы = СокрЛП(Сред(СтрокаРазбора, ПозицияРазделителя + 1));
			Если Нрег(ИмяБазы) = НРег(ИмяБазыДанных) Тогда
				Лог.Информация("Получен УИД базы");
				НайденаБазаВКластере = Истина;
				Прервать;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	Если Не НайденаБазаВКластере Тогда
		ВызватьИсключение "База " + ИмяБазыДанных + " не найдена в кластере";
	КонецЕсли;
	
	Возврат УИДИБ;
	
КонецФункции

Функция СтрокаЗапускаКлиента()

	Результат = "";

	Если ЭтоWindows Тогда 
		Результат = """" + ПутьКлиентаАдминистрирования + """";
	Иначе
		Результат = ПутьКлиентаАдминистрирования;
	КонецЕсли;
	
	Возврат  Результат + " ";
	
КонецФункции

Функция ЗапуститьПроцесс(Знач СтрокаВыполнения)
	Перем ПаузаОжиданияЧтенияБуфера;
	
	ПаузаОжиданияЧтенияБуфера = 20;
	
	Лог.Отладка(СтрокаВыполнения);
	Процесс = СоздатьПроцесс(СтрокаВыполнения, ,Истина);
	Процесс.Запустить();
	
	Текст = Новый ТекстовыйДокумент;
	
	Пока Истина Цикл
		
		ВывестиДанныеПроцесса(Процесс, Текст);
		
		Если Процесс.Завершен Тогда
			Процесс.ОжидатьЗавершения(); // финальный сброс буферов
			ВывестиДанныеПроцесса(Процесс, Текст);
			Прервать;
		КонецЕсли;
		
		Приостановить(ПаузаОжиданияЧтенияБуфера);
		
	КонецЦикла;
	
	Если Процесс.КодВозврата = 0 Тогда
		Возврат Текст.ПолучитьТекст();
	Иначе
		ВызватьИсключение "Сообщение от RAS/RAC 
		|" + Текст.ПолучитьТекст();
	КонецЕсли;	
	
КонецФункции

Процедура ВывестиДанныеПроцесса(Знач Процесс, Знач Приемник)
	Вывод = Процесс.ПотокВывода.Прочитать();
	Ошибки = Процесс.ПотокОшибок.Прочитать();
	Если СтрДлина(Строка(Вывод)) > 0 Тогда
		Приемник.ДобавитьСтроку(Вывод);
	КонецЕсли;
	Если СтрДлина(Строка(Ошибки)) > 0 Тогда
		Приемник.ДобавитьСтроку(Ошибки);
	КонецЕсли;
КонецПроцедуры

СистемнаяИнформация = Новый СистемнаяИнформация;
Лог = Логирование.ПолучитьЛог("vanessa.app.deployka");
ЭтоWindows = Найти(НРег(СистемнаяИнформация.ВерсияОС), "windows") > 0;